import { __awaiter } from "tslib";
import { ulid } from 'ulid';
import { Inspector } from './debug';
import { getString } from './i18n';
import { INPUT, MessageEventAck, MessageEventFrom, } from './models';
import { BotonicOutputParser } from './output-parser';
import { loadPlugins, runPlugins } from './plugins';
import { getComputedRoutes, Router } from './routing';
export class CoreBot {
    constructor({ 
    // TODO: Receives dataProvider
    renderer, routes, locales, theme, plugins, appId, defaultTyping, defaultDelay, defaultRoutes, inspector, }) {
        this.botonicOutputParser = new BotonicOutputParser();
        this.renderer = renderer;
        this.plugins = loadPlugins(plugins);
        this.theme = theme || {};
        this.defaultTyping =
            typeof defaultTyping !== 'undefined' ? defaultTyping : 0.6;
        this.defaultDelay = typeof defaultDelay !== 'undefined' ? defaultDelay : 0.4;
        this.locales = locales;
        if (appId) {
            this.appId = appId;
            return;
        }
        this.rootElement = null;
        this.inspector = inspector || new Inspector();
        this.routes = routes;
        this.defaultRoutes = defaultRoutes || [];
        this.router =
            this.routes instanceof Function
                ? null
                : new Router([...this.routes, ...this.defaultRoutes], this.inspector.routeInspector);
    }
    getString(id, session) {
        // @ts-ignore
        return getString(this.locales, session.__locale, id);
    }
    setLocale(locale, session) {
        session.__locale = locale;
    }
    input({ input, session, lastRoutePath, dataProvider, }) {
        return __awaiter(this, void 0, void 0, function* () {
            session = session || {};
            if (!session.__locale)
                session.__locale = 'en';
            if (input.type === INPUT.CHAT_EVENT) {
                return {
                    input,
                    session,
                    lastRoutePath,
                    dataProvider,
                    response: [],
                    messageEvents: null,
                };
            }
            const parsedUserEvent = this.botonicOutputParser.parseFromUserInput(input);
            const userId = session.user.id;
            if (dataProvider) {
                // TODO: Next iterations. Review cycle of commited events to DB when messages change their ACK
                // @ts-ignore
                const userEvent = yield dataProvider.saveEvent(Object.assign(Object.assign({}, parsedUserEvent), { userId, eventId: ulid(), createdAt: new Date().toISOString(), from: MessageEventFrom.USER, ack: MessageEventAck.RECEIVED }));
            }
            if (this.plugins) {
                yield runPlugins(this.plugins, 'pre', input, session, lastRoutePath, undefined, undefined, dataProvider);
            }
            if (this.routes instanceof Function) {
                this.router = new Router([
                    ...(yield getComputedRoutes(this.routes, {
                        input,
                        session,
                        lastRoutePath,
                    })),
                    ...this.defaultRoutes,
                ], this.inspector.routeInspector);
            }
            const output = this.router.processInput(input, session, lastRoutePath);
            const request = {
                getString: stringId => this.getString(stringId, session),
                setLocale: locale => this.setLocale(locale, session),
                session: session || {},
                params: output.params || {},
                input: input,
                plugins: this.plugins,
                defaultTyping: this.defaultTyping,
                defaultDelay: this.defaultDelay,
                lastRoutePath,
                dataProvider,
            };
            const response = yield this.renderer({
                request,
                actions: [output.fallbackAction, output.action, output.emptyAction],
            });
            let messageEvents = [];
            try {
                messageEvents = this.botonicOutputParser.xmlToMessageEvents(response);
            }
            catch (e) {
                // Disabling Botonic 1.0 error log for LTS version:
                // console.error(e)
            }
            lastRoutePath = output.lastRoutePath;
            if (this.plugins) {
                yield runPlugins(this.plugins, 'post', input, session, lastRoutePath, response, messageEvents, dataProvider);
            }
            if (dataProvider) {
                // TODO: save bot responses to db and update user with new session and new params
                for (const messageEvent of messageEvents) {
                    // @ts-ignore
                    const botEvent = yield dataProvider.saveEvent(Object.assign(Object.assign({}, messageEvent), { userId, eventId: ulid(), createdAt: new Date().toISOString(), from: MessageEventFrom.BOT, ack: MessageEventAck.SENT }));
                }
            }
            session.is_first_interaction = false;
            return {
                input,
                response,
                messageEvents,
                session,
                lastRoutePath,
                dataProvider,
            };
        });
    }
}
//# sourceMappingURL=core-bot.js.map