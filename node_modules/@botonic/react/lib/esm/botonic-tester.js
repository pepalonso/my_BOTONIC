import { __awaiter } from "tslib";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { INPUT } from '@botonic/core';
import React from 'react';
import ReactDOMServer from 'react-dom/server';
import decode from 'unescape';
import { Reply } from './components/reply';
import { Text } from './components/text';
export class BotonicInputTester {
    constructor(bot) {
        this.bot = bot;
    }
    text(inp, session = { user: { id: '123' } }, lastRoutePath = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.bot.input({
                input: { type: INPUT.TEXT, data: inp },
                session: session,
                lastRoutePath: lastRoutePath,
            });
            return decode(res.response);
        });
    }
    payload(inp, session = { user: { id: '123' } }, lastRoutePath = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.bot.input({
                input: { type: INPUT.POSTBACK, payload: inp },
                session: session,
                lastRoutePath: lastRoutePath,
            });
            return decode(res.response);
        });
    }
    path(inp, session = { user: { id: '123' } }, lastRoutePath = '') {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.bot.input({
                input: { type: INPUT.TEXT, payload: `__PATH_PAYLOAD__${inp}` },
                session: session,
                lastRoutePath: lastRoutePath,
            });
            return decode(res.response);
        });
    }
}
export class BotonicOutputTester {
    constructor(bot) {
        this.bot = bot;
    }
    text(out, replies = null) {
        return decode(ReactDOMServer.renderToStaticMarkup(!replies ? (_jsx(Text, { children: out })) : (_jsxs(Text, { children: [out, replies] }))));
    }
    reply({ text, payload = null, path = null }) {
        if (payload) {
            return decode(ReactDOMServer.renderToStaticMarkup(_jsx(Reply, Object.assign({ payload: payload }, { children: text }))));
        }
        if (path) {
            return decode(ReactDOMServer.renderToStaticMarkup(_jsx(Reply, Object.assign({ path: path }, { children: text }))));
        }
        throw new Error('reply should contain a payload or a path');
    }
    replies(...args) {
        const replies = [];
        for (let i = 0; i < args.length; i++) {
            const r = args[i];
            replies.push(this.reply({ text: r.text, payload: r.payload, path: r.path }));
        }
        return replies;
    }
}
//# sourceMappingURL=botonic-tester.js.map