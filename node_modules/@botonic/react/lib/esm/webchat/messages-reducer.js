import { SENDERS } from '../index-types';
import { WebchatAction } from './actions';
export const messagesReducer = (state, action) => {
    switch (action.type) {
        case WebchatAction.ADD_MESSAGE:
            return addMessageReducer(state, action);
        case WebchatAction.ADD_MESSAGE_COMPONENT:
            return addMessageComponent(state, action);
        case WebchatAction.UPDATE_MESSAGE:
            return updateMessageReducer(state, action);
        case WebchatAction.UPDATE_REPLIES:
            return Object.assign(Object.assign({}, state), { replies: action.payload });
        case WebchatAction.CLEAR_MESSAGES:
            return Object.assign(Object.assign({}, state), { messagesJSON: [], messagesComponents: [], numUnreadMessages: 0 });
        case WebchatAction.UPDATE_LAST_MESSAGE_DATE:
            return Object.assign(Object.assign({}, state), { lastMessageUpdate: action.payload });
        case WebchatAction.RESET_UNREAD_MESSAGES:
            return resetUnreadMessages(state);
        case WebchatAction.SET_LAST_MESSAGE_VISIBLE:
            return Object.assign(Object.assign({}, state), { isLastMessageVisible: action.payload });
        default:
            throw new Error();
    }
};
function addMessageComponent(state, action) {
    var _a, _b;
    const messageComponent = action.payload;
    const isUnreadMessage = ((_a = messageComponent.props) === null || _a === void 0 ? void 0 : _a.isUnread) &&
        ((_b = messageComponent.props) === null || _b === void 0 ? void 0 : _b.sentBy) !== SENDERS.user;
    const numUnreadMessages = isUnreadMessage
        ? state.numUnreadMessages + 1
        : state.numUnreadMessages;
    return Object.assign(Object.assign({}, state), { messagesComponents: [...(state.messagesComponents || []), messageComponent], numUnreadMessages });
}
function resetUnreadMessages(state) {
    const messagesComponents = state.messagesComponents.map(messageComponent => {
        if (messageComponent.props.isUnread) {
            messageComponent = Object.assign(Object.assign({}, messageComponent), { props: Object.assign(Object.assign({}, messageComponent.props), { isUnread: false }) });
        }
        return messageComponent;
    });
    const messagesJSON = state.messagesJSON.map(messageJSON => {
        if (messageJSON.isUnread) {
            messageJSON.isUnread = false;
        }
        return messageJSON;
    });
    return Object.assign(Object.assign({}, state), { messagesComponents,
        messagesJSON, numUnreadMessages: 0 });
}
function updateMessageReducer(state, action) {
    const msgIndex = state.messagesJSON.map(m => m.id).indexOf(action.payload.id);
    if (msgIndex > -1) {
        const msgComponent = state.messagesComponents[msgIndex];
        let updatedMessageComponents = {};
        if (msgComponent) {
            const updatedMsgComponent = Object.assign(Object.assign({}, msgComponent), {
                props: Object.assign(Object.assign({}, msgComponent.props), { ack: action.payload.ack }),
            });
            updatedMessageComponents = {
                messagesComponents: [
                    ...state.messagesComponents.slice(0, msgIndex),
                    Object.assign({}, updatedMsgComponent),
                    ...state.messagesComponents.slice(msgIndex + 1),
                ],
            };
        }
        const numUnreadMessages = state.messagesComponents.filter(messageComponent => messageComponent.props.isUnread).length;
        return Object.assign(Object.assign(Object.assign(Object.assign({}, state), { messagesJSON: [
                ...state.messagesJSON.slice(0, msgIndex),
                Object.assign({}, action.payload),
                ...state.messagesJSON.slice(msgIndex + 1),
            ] }), updatedMessageComponents), { numUnreadMessages });
    }
    return state;
}
function addMessageReducer(state, action) {
    if (state.messagesJSON &&
        state.messagesJSON.find(m => m.id === action.payload.id))
        return state;
    return Object.assign(Object.assign({}, state), { messagesJSON: [...(state.messagesJSON || []), action.payload] });
}
//# sourceMappingURL=messages-reducer.js.map