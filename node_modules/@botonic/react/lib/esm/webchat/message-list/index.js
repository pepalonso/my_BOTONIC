import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useContext, useEffect, useRef, useState } from 'react';
import { ROLES, WEBCHAT } from '../../constants';
import { WebchatContext } from '../../contexts';
import { scrollToBottom } from '../../util';
import { StyledScrollbar } from '../components/styled-scrollbar';
import { TypingIndicator } from '../components/typing-indicator';
import { IntroMessage } from './intro-message';
import { ScrollButton } from './scroll-button';
import { ContainerMessage } from './styles';
import { UnreadMessagesBanner } from './unread-messages-banner';
export const WebchatMessageList = props => {
    const { webchatState, getThemeProperty, resetUnreadMessages, setLastMessageVisible, } = useContext(WebchatContext);
    const scrollbarOptions = Object.assign({ enable: true, autoHide: true }, getThemeProperty(WEBCHAT.CUSTOM_PROPERTIES.scrollbar));
    const [firstUnreadMessageId, setFirstUnreadMessageId] = useState();
    const lastMessageRef = useRef(null);
    const handleScrollToBottom = () => {
        resetUnreadMessages();
        scrollToBottom({ host: props.host });
    };
    const showUnreadMessagesBanner = (messageComponentId) => firstUnreadMessageId &&
        messageComponentId === firstUnreadMessageId &&
        webchatState.numUnreadMessages > 0;
    const unreadMessagesBannerRef = useRef(null);
    useEffect(() => {
        var _a;
        const firstUnreadMessage = webchatState.messagesComponents.find(message => message.props.isUnread);
        setFirstUnreadMessageId((_a = firstUnreadMessage === null || firstUnreadMessage === void 0 ? void 0 : firstUnreadMessage.props) === null || _a === void 0 ? void 0 : _a.id);
    }, [webchatState.messagesComponents]);
    useEffect(() => {
        if (webchatState.messagesComponents.length > 0 && lastMessageRef.current) {
            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    setLastMessageVisible(entry.isIntersecting);
                });
            });
            observer.observe(lastMessageRef.current);
        }
    }, [webchatState.messagesComponents]);
    useEffect(() => {
        if (webchatState.isLastMessageVisible && webchatState.typing) {
            scrollToBottom({ host: props.host });
        }
        if (webchatState.isLastMessageVisible) {
            scrollToBottom({ host: props.host });
        }
    }, [webchatState.typing, webchatState.isLastMessageVisible]);
    useEffect(() => {
        if (firstUnreadMessageId) {
            if (unreadMessagesBannerRef.current) {
                unreadMessagesBannerRef.current.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                });
                return;
            }
        }
        else if (lastMessageRef.current) {
            lastMessageRef.current.scrollIntoView({
                behavior: 'smooth',
                block: 'end',
            });
            return;
        }
    }, [firstUnreadMessageId]);
    const showScrollButton = webchatState.numUnreadMessages > 0 && !webchatState.isLastMessageVisible;
    return (_jsxs(_Fragment, { children: [_jsxs(StyledScrollbar, Object.assign({ role: ROLES.MESSAGE_LIST, 
                // TODO: Distinguis between multiple instances of webchat, e.g. `${uniqueId}-botonic-scrollable`
                id: 'botonic-scrollable-content', 
                // @ts-ignore
                scrollbar: scrollbarOptions, autoHide: scrollbarOptions.autoHide, ismessagescontainer: true.toString(), style: Object.assign({}, props.style) }, { children: [_jsx(IntroMessage, {}), webchatState.messagesComponents.map((messageComponent, index) => {
                        return (_jsxs(ContainerMessage, Object.assign({ role: ROLES.MESSAGE }, { children: [showUnreadMessagesBanner(messageComponent.props.id) && (_jsx(UnreadMessagesBanner, { unreadMessagesBannerRef: unreadMessagesBannerRef })), index === webchatState.messagesComponents.length - 1 && (_jsx("div", { ref: lastMessageRef, style: { content: '' } })), messageComponent] }), index));
                    }), webchatState.typing && _jsx(TypingIndicator, {})] })), showScrollButton && _jsx(ScrollButton, { handleClick: handleScrollToBottom })] }));
};
//# sourceMappingURL=index.js.map