"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.customMessage = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const core_1 = require("@botonic/core");
const lodash_merge_1 = tslib_1.__importDefault(require("lodash.merge"));
const react_1 = tslib_1.__importDefault(require("react"));
const index_types_1 = require("../index-types");
const error_boundary_1 = require("../util/error-boundary");
const logs_1 = require("../util/logs");
const react_2 = require("../util/react");
const message_1 = require("./message");
const reply_1 = require("./reply");
/**
 *
 * @param name as it appears at ThemeProps' message.customTypes key
 * @param CustomMessageComponent
 * @param defaultProps Props for the wrapper Message
 * @param ErrorBoundary to recover in case it fails
 */
const customMessage = ({ name, component: CustomMessageComponent, defaultProps = {}, errorBoundary: ErrorBoundary = (0, error_boundary_1.createErrorBoundary)(), }) => {
    const CustomMessage = props => {
        (0, logs_1.warnDeprecatedProps)(defaultProps, 'customMessage:');
        if (defaultProps.sentBy === index_types_1.SENDERS.user) {
            defaultProps.ack = 1;
        }
        return ((0, jsx_runtime_1.jsx)(message_1.Message, Object.assign({}, (0, lodash_merge_1.default)((0, react_2.mapObjectNonBooleanValues)(defaultProps), props), { type: core_1.INPUT.CUSTOM })));
    };
    const splitChildren = props => {
        const { children } = props;
        const isReply = e => e.type === reply_1.Reply;
        try {
            if (!Array.isArray(children) && !isReply(children)) {
                return { replies: null, childrenWithoutReplies: children };
            }
            const childrenArray = react_1.default.Children.toArray(children);
            const replies = childrenArray.filter(isReply);
            const childrenWithoutReplies = childrenArray.filter(e => !isReply(e));
            return {
                replies: replies,
                childrenWithoutReplies,
            };
        }
        catch (e) {
            return { replies: null, childrenWithoutReplies: children };
        }
    };
    const WrappedComponent = props => {
        const { id, children } = props, customMessageProps = tslib_1.__rest(props, ["id", "children"]);
        const { replies, childrenWithoutReplies } = splitChildren(props);
        return ((0, jsx_runtime_1.jsxs)(CustomMessage, Object.assign({ id: id, json: Object.assign(Object.assign({}, customMessageProps), { id, children: childrenWithoutReplies, customTypeName: name }), sentBy: props.sentBy || index_types_1.SENDERS.bot, isUnread: props.isUnread }, { children: [(0, jsx_runtime_1.jsx)(ErrorBoundary, Object.assign({}, customMessageProps, { children: (0, jsx_runtime_1.jsx)(CustomMessageComponent, Object.assign({}, customMessageProps, { children: childrenWithoutReplies })) }), 'errorBoundary'), replies] })));
    };
    WrappedComponent.customTypeName = name;
    // eslint-disable-next-line react/display-name
    WrappedComponent.deserialize = msg => ((0, jsx_runtime_1.jsx)(WrappedComponent, Object.assign({ id: msg.id, json: msg.data }, msg.data, { sentBy: msg.sentBy || index_types_1.SENDERS.bot, isUnread: msg.isUnread }), msg.key));
    return WrappedComponent;
};
exports.customMessage = customMessage;
//# sourceMappingURL=custom-message.js.map