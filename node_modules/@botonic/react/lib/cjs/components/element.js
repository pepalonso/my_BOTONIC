"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Element = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importDefault(require("react"));
const styled_components_1 = tslib_1.__importDefault(require("styled-components"));
const constants_1 = require("../constants");
const react_2 = require("../util/react");
const ElementContainer = styled_components_1.default.div `
  display: flex;
  flex-direction: column;
  width: ${constants_1.WEBCHAT.DEFAULTS.ELEMENT_WIDTH}px;
  margin-right: ${constants_1.WEBCHAT.DEFAULTS.ELEMENT_MARGIN_RIGHT}px;
  border-radius: 6px;
  border: 1px solid ${constants_1.COLORS.SEASHELL_WHITE};
  overflow: hidden;
  justify-content: space-between;
`;
const Element = props => {
    const renderBrowser = () => ((0, jsx_runtime_1.jsx)(ElementContainer, { children: props.children }));
    const renderNode = () => (0, jsx_runtime_1.jsx)("element", { children: props.children });
    return (0, react_2.renderComponent)({ renderBrowser, renderNode });
};
exports.Element = Element;
exports.Element.serialize = elementProps => {
    const element = Object.assign({}, ...elementProps.children
        .filter(c => c && c.type && c.type.name != 'Button')
        .map(c => c.type.serialize && c.type.serialize(c.props)));
    // When we are serializer buttons from backend, we are receiving the data
    // as an array of buttons, so we have to keep robust with serve and deal with arrays
    element.buttons = [
        ...elementProps.children
            .filter(c => {
            if (c instanceof Array)
                return true;
            return c && c.type && c.type.name == 'Button';
        })
            .map(b => {
            if (b instanceof Array) {
                return b.map(bb => bb &&
                    bb.type &&
                    bb.type.serialize &&
                    bb.type.serialize(bb.props).button);
            }
            return (b && b.type && b.type.serialize && b.type.serialize(b.props).button);
        }),
    ];
    // When we have the buttons from backend, we have all buttons inside an array on the first position
    // of another array in element['buttons'] we want that element['buttons'] to be an array of buttons,
    // not an array of another array of buttons
    if (element.buttons[0] instanceof Array)
        element.buttons = element.buttons[0];
    return element;
};
//# sourceMappingURL=element.js.map