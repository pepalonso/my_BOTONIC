"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultichannelButton = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = tslib_1.__importStar(require("react"));
const contexts_1 = require("../../contexts");
const util_1 = require("../../util");
const button_1 = require("../button");
const multichannel_context_1 = require("./multichannel-context");
const multichannel_utils_1 = require("./multichannel-utils");
const MultichannelButton = props => {
    var _a;
    const requestContext = (0, react_1.useContext)(contexts_1.RequestContext);
    const multichannelContext = (0, react_1.useContext)(multichannel_context_1.MultichannelContext);
    const hasUrl = () => Boolean(props.url);
    const hasPath = () => Boolean(props.path);
    const hasPayload = () => Boolean(props.payload);
    const hasPostback = () => hasPath() || hasPayload();
    const hasWebview = () => Boolean(props.webview);
    const getUrl = () => props.url;
    const getWebview = () => props.webview;
    const increaseCurrentIndex = () => {
        if (typeof multichannelContext.currentIndex === 'number') {
            multichannelContext.currentIndex += 1;
        }
        else if (typeof multichannelContext.currentIndex === 'string') {
            const lastChar = multichannelContext.currentIndex.charCodeAt(multichannelContext.currentIndex.length - 1);
            multichannelContext.currentIndex = String.fromCharCode(lastChar + 1);
        }
    };
    const formatIndex = index => {
        var _a;
        const boldIndex = (_a = multichannelContext.boldIndex) !== null && _a !== void 0 ? _a : false;
        return boldIndex ? `*${index}*` : index;
    };
    const getText = () => {
        let text = props.children;
        const newline = props.newline || '';
        const separator = multichannelContext.indexSeparator || ' ';
        const index = multichannelContext.currentIndex
            ? `${formatIndex(multichannelContext.currentIndex + separator)} `
            : '';
        if (hasPostback()) {
            text = newline + `${index}${text}`;
        }
        else if (hasUrl()) {
            text = newline + `- ${text}`;
        }
        return text;
    };
    if ((0, multichannel_utils_1.isWhatsapp)(requestContext)) {
        const asText = (_a = props.asText) !== null && _a !== void 0 ? _a : true;
        if (asText) {
            if (hasUrl()) {
                return `${getText()}: ${getUrl()}`;
            }
            else if (hasPath() || hasPayload()) {
                const text = getText();
                increaseCurrentIndex();
                return `${text}`;
            }
            else if (hasWebview())
                return (0, jsx_runtime_1.jsx)(button_1.Button, Object.assign({}, props, { children: getText() }));
        }
        return ((0, jsx_runtime_1.jsx)(button_1.Button, Object.assign({}, props, { children: (0, util_1.truncateText)(props.children, multichannel_utils_1.WHATSAPP_MAX_BUTTON_CHARS) })));
    }
    return (0, jsx_runtime_1.jsx)(button_1.Button, Object.assign({}, props, { children: props.children }));
};
exports.MultichannelButton = MultichannelButton;
//# sourceMappingURL=multichannel-button.js.map