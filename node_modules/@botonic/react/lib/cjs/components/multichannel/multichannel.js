"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Multichannel = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = tslib_1.__importStar(require("react"));
const constants_1 = require("../../constants");
const contexts_1 = require("../../contexts");
const react_3 = require("../../util/react");
const text_1 = require("../text");
const multichannel_button_1 = require("./multichannel-button");
const multichannel_carousel_1 = require("./multichannel-carousel");
const multichannel_context_1 = require("./multichannel-context");
const multichannel_reply_1 = require("./multichannel-reply");
const multichannel_text_1 = require("./multichannel-text");
const multichannel_utils_1 = require("./multichannel-utils");
const Multichannel = props => {
    const requestContext = (0, react_2.useContext)(contexts_1.RequestContext);
    if (!(0, multichannel_utils_1.isWhatsapp)(requestContext) && !(0, multichannel_utils_1.isFacebook)(requestContext)) {
        return props.children;
    }
    if ((0, multichannel_utils_1.isFacebook)(requestContext)) {
        const newChildren = (0, react_3.deepMapWithIndex)(props.children, child => {
            if (child && child.type && child.type.name === constants_1.COMPONENT_TYPE.TEXT) {
                return ((0, react_1.createElement)(multichannel_text_1.MultichannelText, Object.assign({}, child.props, { key: child.key }), child.props.children));
            }
            return child;
        });
        return newChildren;
    }
    let newChildren = (0, react_3.deepMapWithIndex)(props.children, (child, index) => {
        if (child && child.type && child.type.name === constants_1.COMPONENT_TYPE.BUTTON) {
            return ((0, react_1.createElement)(multichannel_button_1.MultichannelButton, Object.assign({}, child.props, { key: child.key }), child.props.children));
        }
        if (child && child.type && child.type.name === constants_1.COMPONENT_TYPE.REPLY) {
            return ((0, react_1.createElement)(multichannel_reply_1.MultichannelReply, Object.assign({}, child.props, { key: child.key }), child.props.children));
        }
        if (child && child.type && child.type.name === constants_1.COMPONENT_TYPE.TEXT) {
            return ((0, react_1.createElement)(multichannel_text_1.MultichannelText, Object.assign({}, child.props, props.text, { key: child.key }, (props.messageSeparator &&
                index > 0 && { newline: props.messageSeparator })), child.props.children));
        }
        if (child && child.type && child.type.name === constants_1.COMPONENT_TYPE.CAROUSEL) {
            return ((0, react_1.createElement)(multichannel_carousel_1.MultichannelCarousel, Object.assign({}, child.props, props.carousel, { key: child.key }), child.props.children));
        }
        return child;
    });
    if (props.messageSeparator != null) {
        newChildren = newChildren.map((c, index) => index > 0 && typeof c === 'string' ? props.messageSeparator + c : c);
        newChildren = ((0, jsx_runtime_1.jsx)(text_1.Text, Object.assign({}, multichannel_utils_1.MULTICHANNEL_WHATSAPP_PROPS, { children: newChildren }), props.key));
    }
    return ((0, jsx_runtime_1.jsx)(multichannel_context_1.MultichannelContext.Provider, Object.assign({ value: {
            currentIndex: props.firstIndex,
            boldIndex: props.boldIndex,
            indexSeparator: props.indexSeparator,
            messageSeparator: props.messageSeparator,
        } }, { children: newChildren })));
};
exports.Multichannel = Multichannel;
//# sourceMappingURL=multichannel.js.map