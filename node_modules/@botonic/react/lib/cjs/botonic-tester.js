"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BotonicOutputTester = exports.BotonicInputTester = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const core_1 = require("@botonic/core");
const react_1 = tslib_1.__importDefault(require("react"));
const server_1 = tslib_1.__importDefault(require("react-dom/server"));
const unescape_1 = tslib_1.__importDefault(require("unescape"));
const reply_1 = require("./components/reply");
const text_1 = require("./components/text");
class BotonicInputTester {
    constructor(bot) {
        this.bot = bot;
    }
    text(inp, session = { user: { id: '123' } }, lastRoutePath = '') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const res = yield this.bot.input({
                input: { type: core_1.INPUT.TEXT, data: inp },
                session: session,
                lastRoutePath: lastRoutePath,
            });
            return (0, unescape_1.default)(res.response);
        });
    }
    payload(inp, session = { user: { id: '123' } }, lastRoutePath = '') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const res = yield this.bot.input({
                input: { type: core_1.INPUT.POSTBACK, payload: inp },
                session: session,
                lastRoutePath: lastRoutePath,
            });
            return (0, unescape_1.default)(res.response);
        });
    }
    path(inp, session = { user: { id: '123' } }, lastRoutePath = '') {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const res = yield this.bot.input({
                input: { type: core_1.INPUT.TEXT, payload: `__PATH_PAYLOAD__${inp}` },
                session: session,
                lastRoutePath: lastRoutePath,
            });
            return (0, unescape_1.default)(res.response);
        });
    }
}
exports.BotonicInputTester = BotonicInputTester;
class BotonicOutputTester {
    constructor(bot) {
        this.bot = bot;
    }
    text(out, replies = null) {
        return (0, unescape_1.default)(server_1.default.renderToStaticMarkup(!replies ? ((0, jsx_runtime_1.jsx)(text_1.Text, { children: out })) : ((0, jsx_runtime_1.jsxs)(text_1.Text, { children: [out, replies] }))));
    }
    reply({ text, payload = null, path = null }) {
        if (payload) {
            return (0, unescape_1.default)(server_1.default.renderToStaticMarkup((0, jsx_runtime_1.jsx)(reply_1.Reply, Object.assign({ payload: payload }, { children: text }))));
        }
        if (path) {
            return (0, unescape_1.default)(server_1.default.renderToStaticMarkup((0, jsx_runtime_1.jsx)(reply_1.Reply, Object.assign({ path: path }, { children: text }))));
        }
        throw new Error('reply should contain a payload or a path');
    }
    replies(...args) {
        const replies = [];
        for (let i = 0; i < args.length; i++) {
            const r = args[i];
            replies.push(this.reply({ text: r.text, payload: r.payload, path: r.path }));
        }
        return replies;
    }
}
exports.BotonicOutputTester = BotonicOutputTester;
//# sourceMappingURL=botonic-tester.js.map