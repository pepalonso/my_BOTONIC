"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebchatMessageList = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const constants_1 = require("../../constants");
const contexts_1 = require("../../contexts");
const util_1 = require("../../util");
const styled_scrollbar_1 = require("../components/styled-scrollbar");
const typing_indicator_1 = require("../components/typing-indicator");
const intro_message_1 = require("./intro-message");
const scroll_button_1 = require("./scroll-button");
const styles_1 = require("./styles");
const unread_messages_banner_1 = require("./unread-messages-banner");
const WebchatMessageList = props => {
    const { webchatState, getThemeProperty, resetUnreadMessages, setLastMessageVisible, } = (0, react_1.useContext)(contexts_1.WebchatContext);
    const scrollbarOptions = Object.assign({ enable: true, autoHide: true }, getThemeProperty(constants_1.WEBCHAT.CUSTOM_PROPERTIES.scrollbar));
    const [firstUnreadMessageId, setFirstUnreadMessageId] = (0, react_1.useState)();
    const lastMessageRef = (0, react_1.useRef)(null);
    const handleScrollToBottom = () => {
        resetUnreadMessages();
        (0, util_1.scrollToBottom)({ host: props.host });
    };
    const showUnreadMessagesBanner = (messageComponentId) => firstUnreadMessageId &&
        messageComponentId === firstUnreadMessageId &&
        webchatState.numUnreadMessages > 0;
    const unreadMessagesBannerRef = (0, react_1.useRef)(null);
    (0, react_1.useEffect)(() => {
        var _a;
        const firstUnreadMessage = webchatState.messagesComponents.find(message => message.props.isUnread);
        setFirstUnreadMessageId((_a = firstUnreadMessage === null || firstUnreadMessage === void 0 ? void 0 : firstUnreadMessage.props) === null || _a === void 0 ? void 0 : _a.id);
    }, [webchatState.messagesComponents]);
    (0, react_1.useEffect)(() => {
        if (webchatState.messagesComponents.length > 0 && lastMessageRef.current) {
            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    setLastMessageVisible(entry.isIntersecting);
                });
            });
            observer.observe(lastMessageRef.current);
        }
    }, [webchatState.messagesComponents]);
    (0, react_1.useEffect)(() => {
        if (webchatState.isLastMessageVisible && webchatState.typing) {
            (0, util_1.scrollToBottom)({ host: props.host });
        }
        if (webchatState.isLastMessageVisible) {
            (0, util_1.scrollToBottom)({ host: props.host });
        }
    }, [webchatState.typing, webchatState.isLastMessageVisible]);
    (0, react_1.useEffect)(() => {
        if (firstUnreadMessageId) {
            if (unreadMessagesBannerRef.current) {
                unreadMessagesBannerRef.current.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                });
                return;
            }
        }
        else if (lastMessageRef.current) {
            lastMessageRef.current.scrollIntoView({
                behavior: 'smooth',
                block: 'end',
            });
            return;
        }
    }, [firstUnreadMessageId]);
    const showScrollButton = webchatState.numUnreadMessages > 0 && !webchatState.isLastMessageVisible;
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(styled_scrollbar_1.StyledScrollbar, Object.assign({ role: constants_1.ROLES.MESSAGE_LIST, 
                // TODO: Distinguis between multiple instances of webchat, e.g. `${uniqueId}-botonic-scrollable`
                id: 'botonic-scrollable-content', 
                // @ts-ignore
                scrollbar: scrollbarOptions, autoHide: scrollbarOptions.autoHide, ismessagescontainer: true.toString(), style: Object.assign({}, props.style) }, { children: [(0, jsx_runtime_1.jsx)(intro_message_1.IntroMessage, {}), webchatState.messagesComponents.map((messageComponent, index) => {
                        return ((0, jsx_runtime_1.jsxs)(styles_1.ContainerMessage, Object.assign({ role: constants_1.ROLES.MESSAGE }, { children: [showUnreadMessagesBanner(messageComponent.props.id) && ((0, jsx_runtime_1.jsx)(unread_messages_banner_1.UnreadMessagesBanner, { unreadMessagesBannerRef: unreadMessagesBannerRef })), index === webchatState.messagesComponents.length - 1 && ((0, jsx_runtime_1.jsx)("div", { ref: lastMessageRef, style: { content: '' } })), messageComponent] }), index));
                    }), webchatState.typing && (0, jsx_runtime_1.jsx)(typing_indicator_1.TypingIndicator, {})] })), showScrollButton && (0, jsx_runtime_1.jsx)(scroll_button_1.ScrollButton, { handleClick: handleScrollToBottom })] }));
};
exports.WebchatMessageList = WebchatMessageList;
//# sourceMappingURL=index.js.map