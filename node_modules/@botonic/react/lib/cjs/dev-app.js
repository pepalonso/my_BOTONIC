"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevApp = void 0;
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const lodash_merge_1 = tslib_1.__importDefault(require("lodash.merge"));
const react_1 = tslib_1.__importDefault(require("react"));
const react_dom_1 = require("react-dom");
const index_types_1 = require("./index-types");
const react_bot_1 = require("./react-bot");
const dom_1 = require("./util/dom");
const webchat_dev_1 = require("./webchat/webchat-dev");
const webchat_app_1 = require("./webchat-app");
class DevApp extends webchat_app_1.WebchatApp {
    constructor(_a) {
        var { theme = {}, persistentMenu, coverComponent, blockInputs, enableEmojiPicker, enableAttachments, enableUserInput, enableAnimations, shadowDOM, hostId, storage, storageKey, onInit, onOpen, onClose, onMessage } = _a, botOptions = tslib_1.__rest(_a, ["theme", "persistentMenu", "coverComponent", "blockInputs", "enableEmojiPicker", "enableAttachments", "enableUserInput", "enableAnimations", "shadowDOM", "hostId", "storage", "storageKey", "onInit", "onOpen", "onClose", "onMessage"]);
        super({
            theme,
            persistentMenu,
            coverComponent,
            blockInputs,
            enableEmojiPicker,
            enableAttachments,
            enableUserInput,
            enableAnimations,
            shadowDOM,
            hostId,
            storage,
            storageKey,
            onInit,
            onOpen,
            onClose,
            onMessage,
        });
        this.bot = new react_bot_1.ReactBot(Object.assign({}, botOptions));
    }
    getComponent(host, optionsAtRuntime = {}) {
        let { theme = {}, persistentMenu, coverComponent, blockInputs, enableEmojiPicker, enableAttachments, enableUserInput, enableAnimations, storage, storageKey, onInit, onOpen, onClose, onMessage, hostId } = optionsAtRuntime, webchatOptions = tslib_1.__rest(optionsAtRuntime, ["theme", "persistentMenu", "coverComponent", "blockInputs", "enableEmojiPicker", "enableAttachments", "enableUserInput", "enableAnimations", "storage", "storageKey", "onInit", "onOpen", "onClose", "onMessage", "hostId"]);
        theme = (0, lodash_merge_1.default)(this.theme, theme);
        persistentMenu = persistentMenu || this.persistentMenu;
        coverComponent = coverComponent || this.coverComponent;
        blockInputs = blockInputs || this.blockInputs;
        enableEmojiPicker = enableEmojiPicker || this.enableEmojiPicker;
        enableAttachments = enableAttachments || this.enableAttachments;
        enableUserInput = enableUserInput || this.enableUserInput;
        enableAnimations = enableAnimations || this.enableAnimations;
        storage = storage || this.storage;
        storageKey = storageKey || this.storageKey;
        this.onInit = onInit || this.onInit;
        this.onOpen = onOpen || this.onOpen;
        this.onClose = onClose || this.onClose;
        this.onMessage = onMessage || this.onMessage;
        this.hostId = hostId || this.hostId;
        this.createRootElement(host);
        return ((0, jsx_runtime_1.jsx)(webchat_dev_1.WebchatDev, Object.assign({}, webchatOptions, { ref: this.webchatRef, host: this.host, shadowDOM: this.shadowDOM, theme: theme, persistentMenu: persistentMenu, coverComponent: coverComponent, blockInputs: blockInputs, enableEmojiPicker: enableEmojiPicker, enableAttachments: enableAttachments, enableUserInput: enableUserInput, enableAnimations: enableAnimations, storage: storage, storageKey: storageKey, getString: (stringId, session) => this.bot.getString(stringId, session), setLocale: (locale, session) => this.bot.setLocale(locale, session), onInit: (...args) => this.onInitWebchat(...args), onOpen: (...args) => this.onOpenWebchat(...args), onClose: (...args) => this.onCloseWebchat(...args), onUserInput: (...args) => this.onUserInput(...args) })));
    }
    render(dest, optionsAtRuntime = {}) {
        (0, dom_1.onDOMLoaded)(() => {
            (0, react_dom_1.render)(this.getComponent(dest, optionsAtRuntime), this.getReactMountNode(dest));
        });
    }
    onUserInput({ input, session, lastRoutePath }) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.onMessage &&
                this.onMessage(this, {
                    sentBy: index_types_1.SENDERS.user,
                    message: input,
                });
            const resp = yield this.bot.input({ input, session, lastRoutePath });
            this.onMessage &&
                resp.response.map(r => this.onMessage(this, {
                    sentBy: index_types_1.SENDERS.bot,
                    message: r,
                }));
            this.webchatRef.current.addBotResponse(resp);
        });
    }
}
exports.DevApp = DevApp;
//# sourceMappingURL=dev-app.js.map